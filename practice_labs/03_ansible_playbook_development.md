# Lab: Ansible Playbook Development

This lab covers the "Develop playbooks that create and use templates to create customized configuration files" objective of the EX374 exam. You'll learn how to create and use Jinja2 templates to generate configuration files dynamically.

## Prerequisites

- Ansible Automation Platform 2.4 installed according to the [AAP Installation Guide](../guides/aap_installation_guide.md)
- Completion of the [Git Repository Management Lab](01_git_repository_management.md)

## Lab Environment Setup

1. **Create a working directory**
   ```bash
   mkdir -p ~/ansible-labs/templates-lab
   cd ~/ansible-labs/templates-lab
   ```

2. **Initialize a Git repository**
   ```bash
   git init
   ```

3. **Create a basic inventory file**
   ```bash
   cat > inventory << 'EOF'
   [webservers]
   web1 ansible_host=192.168.1.101
   web2 ansible_host=192.168.1.102
   
   [dbservers]
   db1 ansible_host=192.168.1.201
   
   [all:vars]
   ansible_connection=local
   EOF
   ```

## Exercise 1: Creating Basic Templates

In this exercise, you'll create a basic Jinja2 template for an NGINX configuration file.

1. **Create a templates directory**
   ```bash
   mkdir -p templates
   ```

2. **Create a basic NGINX template**
   ```bash
   cat > templates/nginx.conf.j2 << 'EOF'
   # NGINX Configuration for {{ inventory_hostname }}
   # Generated by Ansible on {{ ansible_date_time.date }}
   
   user nginx;
   worker_processes {{ nginx_worker_processes | default(1) }};
   error_log /var/log/nginx/error.log;
   pid /run/nginx.pid;
   
   events {
       worker_connections {{ nginx_worker_connections | default(1024) }};
   }
   
   http {
       include /etc/nginx/mime.types;
       default_type application/octet-stream;
       
       log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';
       
       access_log /var/log/nginx/access.log main;
       
       sendfile on;
       tcp_nopush on;
       tcp_nodelay on;
       keepalive_timeout 65;
       types_hash_max_size 2048;
       
       include /etc/nginx/conf.d/*.conf;
       
       server {
           listen {{ http_port | default(80) }};
           server_name {{ server_name | default('localhost') }};
           root {{ web_root | default('/usr/share/nginx/html') }};
           
           location / {
               index index.html index.htm;
           }
           
           error_page 404 /404.html;
           error_page 500 502 503 504 /50x.html;
       }
   }
   EOF
   ```

3. **Create a playbook to apply the template**
   ```bash
   cat > nginx_config.yml << 'EOF'
   ---
   - name: Configure NGINX
     hosts: webservers
     gather_facts: true
     vars:
       nginx_worker_processes: 2
       nginx_worker_connections: 2048
       http_port: 8080
       server_name: "{{ inventory_hostname }}.example.com"
       web_root: "/var/www/html"
     
     tasks:
       - name: Create output directory
         file:
           path: ./output
           state: directory
       
       - name: Generate NGINX configuration
         template:
           src: templates/nginx.conf.j2
           dest: "./output/{{ inventory_hostname }}_nginx.conf"
         
       - name: Display generated configuration
         command: "cat ./output/{{ inventory_hostname }}_nginx.conf"
         register: config_content
         changed_when: false
         
       - name: Show configuration
         debug:
           var: config_content.stdout_lines
   EOF
   ```

4. **Run the playbook**
   ```bash
   ansible-playbook -i inventory nginx_config.yml
   ```

5. **Examine the generated configuration files**
   ```bash
   ls -la output/
   cat output/web1_nginx.conf
   cat output/web2_nginx.conf
   ```

6. **Commit your changes**
   ```bash
   git add templates/ nginx_config.yml inventory output/
   git commit -m "Add basic NGINX template and configuration playbook"
   ```

## Exercise 2: Using Conditionals in Templates

In this exercise, you'll enhance your templates with conditional logic.

1. **Create an enhanced NGINX template with conditionals**
   ```bash
   cat > templates/nginx_enhanced.conf.j2 << 'EOF'
   # NGINX Configuration for {{ inventory_hostname }}
   # Generated by Ansible on {{ ansible_date_time.date }}
   
   user nginx;
   worker_processes {{ nginx_worker_processes | default(1) }};
   error_log /var/log/nginx/error.log {{ nginx_log_level | default('warn') }};
   pid /run/nginx.pid;
   
   {% if nginx_load_modules | default(false) %}
   include /usr/share/nginx/modules/*.conf;
   {% endif %}
   
   events {
       worker_connections {{ nginx_worker_connections | default(1024) }};
   }
   
   http {
       include /etc/nginx/mime.types;
       default_type application/octet-stream;
       
       log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';
       
       access_log /var/log/nginx/access.log main;
       
       sendfile on;
       tcp_nopush on;
       tcp_nodelay on;
       keepalive_timeout 65;
       types_hash_max_size 2048;
       
       {% if nginx_gzip_enabled | default(true) %}
       # Gzip Settings
       gzip on;
       gzip_min_length 1000;
       gzip_proxied expired no-cache no-store private auth;
       gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
       {% endif %}
       
       include /etc/nginx/conf.d/*.conf;
       
       server {
           listen {{ http_port | default(80) }};
           server_name {{ server_name | default('localhost') }};
           root {{ web_root | default('/usr/share/nginx/html') }};
           
           {% if enable_https | default(false) %}
           listen {{ https_port | default(443) }} ssl;
           ssl_certificate {{ ssl_cert_path }};
           ssl_certificate_key {{ ssl_key_path }};
           ssl_protocols TLSv1.2 TLSv1.3;
           ssl_ciphers HIGH:!aNULL:!MD5;
           {% endif %}
           
           location / {
               index index.html index.htm;
               {% if enable_caching | default(false) %}
               expires {{ cache_expiry | default('1h') }};
               add_header Cache-Control "public";
               {% endif %}
           }
           
           {% if enable_php | default(false) %}
           location ~ \.php$ {
               fastcgi_pass {{ php_fpm_host | default('127.0.0.1') }}:{{ php_fpm_port | default('9000') }};
               fastcgi_index index.php;
               fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
               include fastcgi_params;
           }
           {% endif %}
           
           error_page 404 /404.html;
           error_page 500 502 503 504 /50x.html;
       }
   }
   EOF
   ```

2. **Create a playbook with different server configurations**
   ```bash
   cat > nginx_enhanced_config.yml << 'EOF'
   ---
   - name: Configure Enhanced NGINX
     hosts: webservers
     gather_facts: true
     vars:
       base_config:
         nginx_worker_processes: 2
         nginx_worker_connections: 2048
         http_port: 80
         web_root: "/var/www/html"
         nginx_gzip_enabled: true
     
     tasks:
       - name: Create output directory
         file:
           path: ./output
           state: directory
       
       - name: Set web1 specific configuration
         set_fact:
           server_config:
             server_name: "web1.example.com"
             enable_https: true
             https_port: 443
             ssl_cert_path: "/etc/nginx/ssl/web1.crt"
             ssl_key_path: "/etc/nginx/ssl/web1.key"
             enable_php: true
             php_fpm_host: "127.0.0.1"
             php_fpm_port: 9000
             nginx_load_modules: true
             nginx_log_level: "info"
         when: inventory_hostname == "web1"
       
       - name: Set web2 specific configuration
         set_fact:
           server_config:
             server_name: "web2.example.com"
             enable_https: false
             enable_caching: true
             cache_expiry: "2h"
             nginx_load_modules: false
             nginx_log_level: "warn"
         when: inventory_hostname == "web2"
       
       - name: Combine configurations
         set_fact:
           combined_config: "{{ base_config | combine(server_config) }}"
       
       - name: Generate enhanced NGINX configuration
         template:
           src: templates/nginx_enhanced.conf.j2
           dest: "./output/{{ inventory_hostname }}_nginx_enhanced.conf"
         vars: "{{ combined_config }}"
         
       - name: Display generated configuration
         command: "cat ./output/{{ inventory_hostname }}_nginx_enhanced.conf"
         register: config_content
         changed_when: false
         
       - name: Show configuration
         debug:
           var: config_content.stdout_lines
   EOF
   ```

3. **Run the playbook**
   ```bash
   ansible-playbook -i inventory nginx_enhanced_config.yml
   ```

4. **Examine the generated configuration files**
   ```bash
   cat output/web1_nginx_enhanced.conf
   cat output/web2_nginx_enhanced.conf
   ```

5. **Commit your changes**
   ```bash
   git add templates/nginx_enhanced.conf.j2 nginx_enhanced_config.yml
   git commit -m "Add enhanced NGINX template with conditionals"
   ```

## Exercise 3: Using Loops in Templates

In this exercise, you'll use loops in templates to generate repetitive configuration sections.

1. **Create a template for a virtual hosts configuration**
   ```bash
   cat > templates/vhosts.conf.j2 << 'EOF'
   # Virtual Hosts Configuration for {{ inventory_hostname }}
   # Generated by Ansible on {{ ansible_date_time.date }}
   
   {% for vhost in virtual_hosts %}
   server {
       listen {{ vhost.port | default(80) }};
       server_name {{ vhost.server_name }};
       root {{ vhost.document_root }};
       
       {% if vhost.ssl | default(false) %}
       listen {{ vhost.ssl_port | default(443) }} ssl;
       ssl_certificate {{ vhost.ssl_cert }};
       ssl_certificate_key {{ vhost.ssl_key }};
       ssl_protocols TLSv1.2 TLSv1.3;
       {% endif %}
       
       access_log /var/log/nginx/{{ vhost.server_name }}_access.log;
       error_log /var/log/nginx/{{ vhost.server_name }}_error.log;
       
       {% if vhost.locations is defined %}
       {% for location in vhost.locations %}
       location {{ location.path }} {
           {% if location.proxy is defined %}
           proxy_pass {{ location.proxy }};
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           {% else %}
           {% if location.alias is defined %}
           alias {{ location.alias }};
           {% endif %}
           {% if location.try_files is defined %}
           try_files {{ location.try_files }};
           {% endif %}
           {% endif %}
           
           {% if location.options is defined %}
           {% for key, value in location.options.items() %}
           {{ key }} {{ value }};
           {% endfor %}
           {% endif %}
       }
       {% endfor %}
       {% endif %}
   }
   {% endfor %}
   EOF
   ```

2. **Create a playbook to generate virtual hosts configuration**
   ```bash
   cat > vhosts_config.yml << 'EOF'
   ---
   - name: Configure Virtual Hosts
     hosts: webservers
     gather_facts: true
     vars:
       web1_vhosts:
         - server_name: "example.com www.example.com"
           document_root: "/var/www/example.com"
           port: 80
           ssl: true
           ssl_port: 443
           ssl_cert: "/etc/nginx/ssl/example.com.crt"
           ssl_key: "/etc/nginx/ssl/example.com.key"
           locations:
             - path: "/"
               try_files: "$uri $uri/ /index.php?$args"
             - path: "~ \.php$"
               proxy: "http://127.0.0.1:9000"
               options:
                 fastcgi_index: "index.php"
                 include: "fastcgi_params"
         
         - server_name: "blog.example.com"
           document_root: "/var/www/blog.example.com"
           port: 80
           locations:
             - path: "/"
               try_files: "$uri $uri/ /index.php?$args"
             - path: "/static/"
               alias: "/var/www/static/"
               options:
                 expires: "30d"
                 add_header: "Cache-Control public"
       
       web2_vhosts:
         - server_name: "api.example.com"
           document_root: "/var/www/api.example.com"
           port: 80
           ssl: true
           ssl_port: 443
           ssl_cert: "/etc/nginx/ssl/api.example.com.crt"
           ssl_key: "/etc/nginx/ssl/api.example.com.key"
           locations:
             - path: "/"
               proxy: "http://127.0.0.1:8000"
             - path: "/docs/"
               alias: "/var/www/api-docs/"
         
         - server_name: "static.example.com"
           document_root: "/var/www/static.example.com"
           port: 80
           locations:
             - path: "/"
               options:
                 expires: "1y"
                 add_header: "Cache-Control public"
     
     tasks:
       - name: Create output directory
         file:
           path: ./output
           state: directory
       
       - name: Set virtual hosts for web1
         set_fact:
           virtual_hosts: "{{ web1_vhosts }}"
         when: inventory_hostname == "web1"
       
       - name: Set virtual hosts for web2
         set_fact:
           virtual_hosts: "{{ web2_vhosts }}"
         when: inventory_hostname == "web2"
       
       - name: Generate virtual hosts configuration
         template:
           src: templates/vhosts.conf.j2
           dest: "./output/{{ inventory_hostname }}_vhosts.conf"
         
       - name: Display generated configuration
         command: "cat ./output/{{ inventory_hostname }}_vhosts.conf"
         register: config_content
         changed_when: false
         
       - name: Show configuration
         debug:
           var: config_content.stdout_lines
   EOF
   ```

3. **Run the playbook**
   ```bash
   ansible-playbook -i inventory vhosts_config.yml
   ```

4. **Examine the generated configuration files**
   ```bash
   cat output/web1_vhosts.conf
   cat output/web2_vhosts.conf
   ```

5. **Commit your changes**
   ```bash
   git add templates/vhosts.conf.j2 vhosts_config.yml
   git commit -m "Add virtual hosts template with loops"
   ```

## Exercise 4: Using Filters in Templates

In this exercise, you'll use Jinja2 filters to transform data in templates.

1. **Create a template that uses filters**
   ```bash
   cat > templates/app_config.j2 << 'EOF'
   # Application Configuration for {{ inventory_hostname | upper }}
   # Generated on: {{ ansible_date_time.date }}
   
   [general]
   app_name = {{ app_name | default('MyApp') }}
   debug_mode = {{ debug | default(false) | lower }}
   environment = {{ environment | default('production') | upper }}
   
   [database]
   host = {{ db_host | default('localhost') }}
   port = {{ db_port | default(5432) }}
   name = {{ db_name | default('app_db') }}
   user = {{ db_user | default('app_user') }}
   password = {{ db_password | default('') | password_hash('sha512') if mask_passwords else db_password | default('') }}
   max_connections = {{ db_max_connections | default(100) }}
   
   [cache]
   enabled = {{ cache_enabled | default(true) | lower }}
   {% if cache_servers is defined %}
   servers = {{ cache_servers | join(',') }}
   {% else %}
   servers = localhost:11211
   {% endif %}
   
   [paths]
   base_dir = {{ base_dir | default('/opt/app') | regex_replace('^(.*)/$', '\\1') }}
   log_dir = {{ log_dir | default(base_dir + '/logs') | regex_replace('^(.*)/$', '\\1') }}
   data_dir = {{ data_dir | default(base_dir + '/data') | regex_replace('^(.*)/$', '\\1') }}
   temp_dir = {{ temp_dir | default(base_dir + '/tmp') | regex_replace('^(.*)/$', '\\1') }}
   
   [security]
   {% if allowed_ips is defined %}
   allowed_ips = {{ allowed_ips | ipaddr('address') | join(',') }}
   {% endif %}
   
   {% if api_keys is defined %}
   [api_keys]
   {% for service, key in api_keys.items() %}
   {{ service | replace(' ', '_') | lower }} = {{ key }}
   {% endfor %}
   {% endif %}
   
   [features]
   {% if features is defined %}
   {% for feature, enabled in features.items() %}
   {{ feature | replace(' ', '_') | lower }} = {{ enabled | bool | lower }}
   {% endfor %}
   {% endif %}
   EOF
   ```

2. **Create a playbook to generate application configuration**
   ```bash
   cat > app_config.yml << 'EOF'
   ---
   - name: Generate Application Configuration
     hosts: all
     gather_facts: true
     vars:
       mask_passwords: true
       
       web_server_config:
         app_name: "WebApp"
         environment: "staging"
         debug: true
         base_dir: "/opt/webapp/"
         db_host: "db1"
         db_name: "webapp_db"
         db_user: "webapp_user"
         db_password: "webapp_password"
         cache_enabled: true
         cache_servers:
           - "cache1:11211"
           - "cache2:11211"
         allowed_ips:
           - "192.168.1.0/24"
           - "10.0.0.1"
           - "invalid_ip"  # This will be filtered out
         api_keys:
           "Payment Gateway": "pg_key_123456"
           "Email Service": "em_key_abcdef"
         features:
           "User Registration": true
           "Social Login": false
           "Two Factor Auth": true
       
       db_server_config:
         app_name: "DBApp"
         environment: "production"
         debug: false
         base_dir: "/opt/dbapp"
         db_max_connections: 200
         features:
           "Automated Backups": true
           "Replication": true
     
     tasks:
       - name: Create output directory
         file:
           path: ./output
           state: directory
       
       - name: Set configuration for webservers
         set_fact:
           app_config: "{{ web_server_config }}"
         when: inventory_hostname in groups['webservers']
       
       - name: Set configuration for dbservers
         set_fact:
           app_config: "{{ db_server_config }}"
         when: inventory_hostname in groups['dbservers']
       
       - name: Generate application configuration
         template:
           src: templates/app_config.j2
           dest: "./output/{{ inventory_hostname }}_app.conf"
         vars: "{{ app_config }}"
         
       - name: Display generated configuration
         command: "cat ./output/{{ inventory_hostname }}_app.conf"
         register: config_content
         changed_when: false
         
       - name: Show configuration
         debug:
           var: config_content.stdout_lines
   EOF
   ```

3. **Run the playbook**
   ```bash
   ansible-playbook -i inventory app_config.yml
   ```

4. **Examine the generated configuration files**
   ```bash
   cat output/web1_app.conf
   cat output/web2_app.conf
   cat output/db1_app.conf
   ```

5. **Commit your changes**
   ```bash
   git add templates/app_config.j2 app_config.yml
   git commit -m "Add application configuration template with filters"
   ```

## Exercise 5: Creating Multi-Environment Configurations

In this exercise, you'll create templates that generate different configurations for different environments.

1. **Create a directory structure for multi-environment configurations**
   ```bash
   mkdir -p templates/environments/{dev,staging,prod}
   ```

2. **Create base template**
   ```bash
   cat > templates/environments/base_config.j2 << 'EOF'
   # Base Configuration for {{ app_name }}
   # Environment: {{ env }}
   # Server: {{ inventory_hostname }}
   # Generated: {{ ansible_date_time.date }}
   
   [application]
   name = {{ app_name }}
   version = {{ app_version }}
   log_level = {{ log_level }}
   
   [database]
   host = {{ db_host }}
   port = {{ db_port }}
   name = {{ db_name }}
   user = {{ db_user }}
   password = {{ db_password }}
   
   [cache]
   enabled = {{ cache_enabled | lower }}
   {% if cache_servers is defined %}
   servers = {{ cache_servers | join(',') }}
   {% endif %}
   
   {% block environment_specific %}
   # Environment specific settings will be included here
   {% endblock %}
   EOF
   ```

3. **Create environment-specific templates**
   ```bash
   cat > templates/environments/dev/config.j2 << 'EOF'
   {% extends "environments/base_config.j2" %}
   
   {% block environment_specific %}
   [development]
   debug = true
   mock_services = {{ mock_services | default(true) | lower }}
   auto_reload = true
   
   [security]
   disable_auth = {{ disable_auth | default(false) | lower }}
   allow_all_origins = true
   {% endblock %}
   EOF
   
   cat > templates/environments/staging/config.j2 << 'EOF'
   {% extends "environments/base_config.j2" %}
   
   {% block environment_specific %}
   [staging]
   debug = false
   mock_services = {{ mock_services | default(false) | lower }}
   performance_monitoring = true
   
   [security]
   disable_auth = false
   allowed_origins = {{ allowed_origins | join(',') }}
   rate_limiting = true
   {% endblock %}
   EOF
   
   cat > templates/environments/prod/config.j2 << 'EOF'
   {% extends "environments/base_config.j2" %}
   
   {% block environment_specific %}
   [production]
   debug = false
   performance_monitoring = true
   high_availability = true
   
   [security]
   disable_auth = false
   allowed_origins = {{ allowed_origins | join(',') }}
   rate_limiting = true
   ip_filtering = true
   {% if allowed_ips is defined %}
   allowed_ips = {{ allowed_ips | join(',') }}
   {% endif %}
   
   [scaling]
   min_instances = {{ min_instances | default(2) }}
   max_instances = {{ max_instances | default(10) }}
   auto_scaling = {{ auto_scaling | default(true) | lower }}
   {% endblock %}
   EOF
   ```

4. **Create a playbook to generate multi-environment configurations**
   ```bash
   cat > multi_env_config.yml << 'EOF'
   ---
   - name: Generate Multi-Environment Configurations
     hosts: all
     gather_facts: true
     vars:
       base_config:
         app_name: "MyApplication"
         app_version: "1.2.3"
         db_port: 5432
         cache_enabled: true
       
       environments:
         dev:
           log_level: "DEBUG"
           db_host: "localhost"
           db_name: "myapp_dev"
           db_user: "dev_user"
           db_password: "dev_password"
           cache_servers:
             - "localhost:11211"
           mock_services: true
           disable_auth: true
         
         staging:
           log_level: "INFO"
           db_host: "db.staging.example.com"
           db_name: "myapp_staging"
           db_user: "staging_user"
           db_password: "staging_password"
           cache_servers:
             - "cache1.staging.example.com:11211"
             - "cache2.staging.example.com:11211"
           allowed_origins:
             - "https://staging.example.com"
             - "https://admin.staging.example.com"
         
         prod:
           log_level: "WARN"
           db_host: "db.prod.example.com"
           db_name: "myapp_prod"
           db_user: "prod_user"
           db_password: "prod_password"
           cache_servers:
             - "cache1.prod.example.com:11211"
             - "cache2.prod.example.com:11211"
             - "cache3.prod.example.com:11211"
           allowed_origins:
             - "https://example.com"
             - "https://admin.example.com"
           allowed_ips:
             - "192.168.1.0/24"
             - "10.0.0.0/16"
           min_instances: 3
           max_instances: 20
     
     tasks:
       - name: Create output directory
         file:
           path: "./output/{{ item }}"
           state: directory
         loop:
           - dev
           - staging
           - prod
       
       - name: Generate development configuration
         template:
           src: templates/environments/dev/config.j2
           dest: "./output/dev/{{ inventory_hostname }}_config.conf"
         vars:
           env: "development"
           config: "{{ environments.dev | combine(base_config) }}"
         vars: "{{ environments.dev | combine(base_config) }}"
       
       - name: Generate staging configuration
         template:
           src: templates/environments/staging/config.j2
           dest: "./output/staging/{{ inventory_hostname }}_config.conf"
         vars:
           env: "staging"
           config: "{{ environments.staging | combine(base_config) }}"
         vars: "{{ environments.staging | combine(base_config) }}"
       
       - name: Generate production configuration
         template:
           src: templates/environments/prod/config.j2
           dest: "./output/prod/{{ inventory_hostname }}_config.conf"
         vars:
           env: "production"
           config: "{{ environments.prod | combine(base_config) }}"
         vars: "{{ environments.prod | combine(base_config) }}"
       
       - name: Display generated configurations
         command: "cat ./output/{{ item }}/{{ inventory_hostname }}_config.conf"
         register: config_content
         changed_when: false
         loop:
           - dev
           - staging
           - prod
         
       - name: Show configurations
         debug:
           msg: "{{ item.stdout_lines }}"
         loop: "{{ config_content.results }}"
         loop_control:
           label: "{{ item.item }}"
   EOF
   ```

5. **Run the playbook**
   ```bash
   ansible-playbook -i inventory multi_env_config.yml
   ```

6. **Examine the generated configuration files**
   ```bash
   ls -la output/dev/
   ls -la output/staging/
   ls -la output/prod/
   
   cat output/dev/web1_config.conf
   cat output/staging/web1_config.conf
   cat output/prod/web1_config.conf
   ```

7. **Commit your changes**
   ```bash
   git add templates/environments/ multi_env_config.yml
   git commit -m "Add multi-environment configuration templates"
   ```

## Conclusion

In this lab, you've learned how to:
- Create basic Jinja2 templates for configuration files
- Use conditionals in templates to generate different configurations based on conditions
- Use loops in templates to generate repetitive configuration sections
- Apply filters to transform data in templates
- Create multi-environment configurations using template inheritance

These skills are essential for the "Develop playbooks that create and use templates to create customized configuration files" objective of the EX374 exam.

## Additional Resources

- [Ansible Templating Documentation](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html)
- [Jinja2 Template Designer Documentation](https://jinja.palletsprojects.com/en/3.0.x/templates/)
- [Ansible Filter Documentation](https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html)
